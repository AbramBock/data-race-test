#summary Initialization State

Current hybrid detection scheme in Helgrind has a mode, similar to Eraser's *initialization state*.

Consider two tests: 

*TEST1:*
{{{
  int *p = 0;
  Thread1() {
	p = new int;
	*p = 1;
  }

  Thread2() {
	sleep(1);
	*p = 2;
  }
}}}

*TEST2:*
{{{
  int *p = 0;
  Thread1() {
	int *x = new int;
	*x = 1;
	mu.Lock();
	p = x;
	mu.Unlock();
  }

  Thread2() {
	sleep(1);
	int *x = 0;
	mu.Lock();
	x = p;
	mu.Unlock();
	if (x) {
	  *x = 2;
	}
  }
}}}


The first test is buggy -- it has a race.

The second test is correct -- it safely publishes the object.

But from Helgrind's point of view these two tests are the same and
Helgrind reports a race in both cases.

Now, if we want to avoid the false positive in the second test we have
these choices:
  * Use `ANNOTATE_CONDVAR_{SIGNAL,WAIT}` pair (most helgrind-friendly)
  * Use `ANNOTATE_PUBLISH_MEMORY_RANGE` (most user friendly)
  * Use `ANNOTATE_MUTEX_IS_USED_AS_COND_VAR` (a big hummer, use it only in
complicated cases)
  * Use `--pure-happens-before=yes` (doesn't really work well, too slow)
  * Use some other race detector which uses a pure happens-before scheme.

We've implemented a new helgrind switch, --initialization-state=yes,
that will miss the race on TEST1 and will avoid false positive on
TEST2.
This is how it works (for curious):
  * The initialization_bit is set for each new memory location.
  * If the initialization_bit is set:
    * If the new access happens in the same thread as the previous access,
     the initialization_bit remains set.
    * Otherwise the initialization_bit is cleared and we transition to
      exclusive state containing the new thread's segment.

