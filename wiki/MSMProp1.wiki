#summary Proposed memory state machine, MSMProp1

For legend see  MemoryStateMachines. 


    http://data-race-test.googlecode.com/svn/trunk/msm/prop1.png
|| *Edge* || *Old state* || *Access type*     ||  *Condition*     || *New state* || *Segment set*     || *Lock set*      || *Race if ...* ||
|| E1     || New         || read              ||  -               || Read        || {currS}           || {currLS}        || - ||
|| E2     || New         || write             ||  -               || Write       || {currS}           || {currLS}        || - ||
|| E3     || Read        || read              ||  -               || Read        || *SS_update*       || *LS_update*     || - ||
|| E4     || Read        || write             ||  -               || Write       || *SS_update*       || *LS_update*     || #LS==0 && #SS > 1 ||
|| E5     || Write       || read              || *HB(SS, currS)*  || Read        || {currS}           || {currLS}        || -      ||
|| E6 (r) || Write       || read              || *!HB(SS, currS)* || Write       || *SS_update*       || *LS_update*     || #LS==0 && #SS > 1 ||
|| E6 (w) || Write       || write             ||  -               || Write       || *SS_update*       || *LS_update*     || #LS==0 && #SS > 1 ||
 


*SS_update*:
{{{
  def SS_update:
    newSS = {currS}
    for S in oldSS: 
      if(!HB(S,currS)): 
        newSS.insert(S)
    SS = newSS
}}}

*LS_update*:
{{{
  def LS_update: 
    if(HB(oldSS, currS)): 
      newLS = currLS
    else:
      newLS = intersect(LS, currLS)
    LS = newLS
}}}


Compared to [MSMHelgrind] this state machine fixes at least these tests: 
  * False negative *test10*. 
  * False positives *test11*, *test12*, *test13*, *test14*, *test16*, *test17*, *test32*, *test39*, *test40*, *test44*.
This state machine still has several false positives (*test28, test29, test36, test38, test46*).
See tests in RacecheckUnittest. 

Tests *test16, test17, test39* pass with this machine only with BarrierSupport.  

== Implementation == 
First quick-and-dirty implementation is done. 
See [http://data-race-test.googlecode.com/svn/trunk/helgrind/hg_main.c hg_main.c], search for *prop1*. 

Performance optimization is *not* done yet.

== Performance considerations == 
This scheme is most likely slower than the [MSMHelgrind], but various optimizations should be possible. 
  * HB (happens before) should be computed only once per state transition (done). 
  * HB results could be cached for {segment-set,segment} pairs (for {segment,segment} pairs it is already cached). 
  * For large segment sets we may want to be more conservative and assume HB==False for all segments (performance vs accuracy trade-off). 
  * A segment set consisting of just one segment should not require any function call to extract the single segment (done). 
