#summary Proposed memory state machine, MSMProp1
*TODO*

DISCLAIMER: this state machine has not (yet) been tested. 

    http://data-race-test.googlecode.com/svn/trunk/msm/prop1.png
|| *Edge* || *Transition*      || *access type*     || *condition*    || *segment set*     || *lock set*      || *race if ...* ||
|| E1     || !NoAccess => New  || memory allocation || -              || -                 || {}              || - ||
|| E2     || New => Read       || read              || -              || {currS}           || {currLS}        || - ||
|| E3     || New => Write      || write             || -              || {currS}           || {currLS}        || - ||
|| E4     || Read => Read      || read              || -              || *SS_update*       || *LS_update*     || - ||
|| E5     || Read => Write     || write             || -              || *SS_update*       || *LS_update*     || LS=={} ||
|| E6     || Write => Read     || read              || HB(SS, currS)  || {currS}           || {currLS}        || -      ||
|| E7     || Write => Write    || read/write        || -              || *SS_update*       || *LS_update*     || LS=={} ||
 

Edges that lead to states !NoAccess and  New are not shown. 

*SS_update*:
{{{
  def SS_update:
    newSS = {currS}
    for S in oldSS: 
      if(!HB(S,currS)): 
        newSS.insert(S)
    SS = newSS
}}}

*LS_update*:
{{{
  def LS_update: 
    if(HB(oldSS, currS)): 
      newLS = currLS
    else:
      newLS = intersect(LS, currLS)
    LS = newLS
}}}


This state machine leads to several false positives (*test28, test29, test36, test38*).
See tests in http://data-race-test.googlecode.com/svn/trunk/unittest/racecheck_unittest.cc. 

See legend in  MemoryStateMachines. 

== Performance considerations == 
This scheme is most likely slower than the MSMHelgrind, but various optimizations should be possible. 
  * HB (happens before) should be computed only once per state transition. 
  * HB results could be cached for {segment-set,segment} pairs (for {segment,segment} pairs it is already cached). 
  * For large segment sets we may want to be more conservative and assume HB==False for all segments (performance vs accuracy trade-off). 
  * A segment set consisting of just one segment should not require any function call to extract the single segment. 
